# Client Development

Most functionality in Simple IoT is implemented in Clients.

![app-arch](images/arch-app.png)

Each client is configured by one or more nodes in the SIOT store graph. These
nodes may be created by a user, a process that detects new plug and play
hardware, or other clients.

A client interacts with the system by listening for new points it is interested
in and sending out points as it acquires new data.

## Creating new clients

Simple IoT provides utilities that assist in creating new clients. See the
[Go package documentation](https://pkg.go.dev/github.com/simpleiot/simpleiot/client)
for more information. A client manager is created for each client type. This
manager instantiates new client instances when new nodes are detected and then
sends point updates to the client. Two levels of nodes are currently supported
for client configuration. An example of this would be a Rule node that has
Condtion and Action child nodes.

## Client lifecycle

It is important the clients cleanly implement the
[Start()/Stop() pattern](architecture-app.md#application-lifecycle) and shut
down cleanly when Stop() is called releasing all resources. If nodes are added
or removed, clients are started/stopped. Additionally if a child node of a
client config is added or removed, the entire client is stopped and then
restarted. This relieves the burden on the client from managing the
addition/removal of client functionality.

## Message echo

Clients need to be aware of the "echo" problem as they typically subscribe as
well as publish to the `points` subject for the nodes they manage. When they
publish to these subjects, these messages will be echoed back to them. There are
several solutions:

1. create a new NATS connection for the client with the
   [NoEcho](https://docs.nats.io/using-nats/developer/connecting/noecho) option
   set. For this to work, each client will need to establish its own connection
   to the server. This may not work in cases where subjects are aliased into
   authenticated subject namespaces.
2. inspect the `Point` `Origin` field -- if is blank, then it was generated by
   the node that owns the point and and does not need to be processed by the
   client generating the data for that node. If is not blank, then the Point was
   generated by a user, rule, or something other than the owning node and must
   be processed. This may not always work -- example: user is connected to a
   downstream instance and modifies a point that then propagates upstream -- it
   may get echo'd back to an authenticated client.
3. A NATS messages header can be populated with the ID of the client that sent
   the message. If it is an authenticated client, then the message will not be
   echo'd on the authenticated client subject namespace of the same ID.

The 3rd option is probably the most robust, but we're still early in this
development and will learn more as time goes on.
